## Java内存访问重排序---笔记
转载自美团技术团队-[Java内存访问重排序的研究](https://tech.meituan.com/2014/09/23/java-memory-reordering.html)

##### 微处理器都会采用将指令乱序执行
>   大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，
>   在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。
>   通过乱序执行的技术，处理器可以大大提高执行效率。

>   除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作4，
>   即生成的机器指令与字节码指令顺序不一致。

##### as-if-serial语义
> As-if-serial语义的意思是，所有的动作(Action)5都可以为了优化而被重排序，
> 但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。  
> Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。   
> 比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。

##### 内存访问重排序与内存可见性
> 计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。
> 即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。
> 这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。
> 从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。

> 有的观点会将这种现象也视为重排序的一种，命名为“内存系统重排序”。
> 因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。


###### 下面部分现在有点难于理解 , 以后再回来填坑

##### 内存访问重排序与Java内存模型
> 待续

##### Intel 64/IA-32架构下的内存访问重排序
> 待续
