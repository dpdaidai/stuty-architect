## Java中的Atomic原子特性-笔记
转载 [Java中的Atomic原子特性](https://blog.csdn.net/qq_30379689/article/details/80785650)

#### 基本概念
一、volatile

用volatile修饰的变量，线程在每次修改变量的时候，都会读取变量修改后的值，可以简单的理解为volatile修饰的变量保存的是变量的地址。volatile变量具有synchronized的可见性，但是不具备原子性

+ 可见性：在多线程并发的条件下，对于变量的修改，其他线程中能获取到修改后的值
+ 原子性：在多线程并发的条件下，对于变量的操作是线程安全的，不会受到其他线程的干扰
volatile不是线程安全的，要使volatile变量提供理想的线程安全，必须同时满足下面两个条件

+ 对变量的写操作不依赖于当前值
+ 该变量没有包含在具有其他变量的不变式中
比如增量操作（x++）看上去类似一个单独操作，实际上它是一个由[读取－修改－写入]操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作，应该使x的值在操作期间保持线程安全，而volatile变量无法实现这点

然而，Java提供了java.util.concurrent.atomic.*包下的变量或引用，让变量或对象的操作具有原子性，在高并发的情况下，依然能保持获取到最新修改的值，常见的有AtomicBoolean、AtomicReference等

+ volatile原理：对于值的操作，会立即更新到主存中，当其他线程获取最新值时会从主存中获取
+ atomic原理：对于值的操作，是基于底层硬件处理器提供的原子指令，保证并发时线程的安全

二、Atomic

Atomic的包名为java.util.concurrent.atomic。这个包里面提供了一组原子变量的操作类，
这些类可以保证在多线程环境下，当某个线程在执行atomic的方法时，不会被其他线程打断，
而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个线程执行

三、CAS

1、CAS简介

CAS指的是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。
这个指令会对内存中的共享数据做原子的读写操作。
在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换，
是实现并发算法时常用到的一种技术。
java.util.concurrent包中借助CAS实现了区别于synchronized同步锁的一种乐观锁。
乐观锁就是每次去取数据的时候都乐观的认为数据不会被修改，因此这个过程不会上锁，
但是在更新的时候会判断一下在此期间的数据有没有更新

2、CAS思想

CAS有三个参数，当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，
将内存值修改为B并返回true，否则什么都不做，并返回false

3、CAS优缺点

系统在硬件层面保证了CAS操作的原子性，不会锁住当前线程，它的效率是很高的。
**但是在并发越高的条件下，失败的次数会越多，CAS如果长时间不成功，会极大的增加CPU的开销，因此CAS不适合竞争十分频繁的场景**
CAS只能保证一个共享变量的原子操作，对多个共享变量操作时，无法保证操作的原子性，
这时就可以用锁，或者把多个共享变量合并成一个共享变量来操作。
JDK提供了AtomicReference类来保证引用对象的原子性，可以把多个变量放在一个对象里来进行CAS操作
四、ABA

CAS在操作值的时候检查值是否已经变化，没有变化的情况下才会进行更新。
但是如果一个值原来是A，变成B，又变成A，那么CAS进行检查时会认为这个值没有变化，但是实际上却变化了。
ABA问题的解决方法是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，
那么A－B－A就变成1A－2B－3A。JDK提供了AtomicStampedReference来解决ABA问题
